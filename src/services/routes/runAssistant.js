import express from 'express';
import { AzureOpenAI } from 'openai';
import dotenv from 'dotenv';
import { getAssistantClient } from '../assistantClient.js';
import { getAssistant } from '../assistant.js';
import { getOrCreateThread } from '../threadManager.js';
import { Mutex } from 'async-mutex';
import { emitEvent } from '../appInsights.js'

const router = express.Router();

router.post('/runAssistant', async (req, res) => {
    try {
        const { message, threadId, age, language, sessionId } = req.body;
        console.log("Session id:", sessionId);
        const { result, runId } = await runAssistantBackend(
            message,
            threadId,
            age,
            language,
            sessionId
        );
        sessionRunMap.set(sessionId, { threadId, runId });
        emitEvent(
        "ChatEvent",
        {
          p_question: message,
          p_age: age,
          p_language: language,
          p_sessionId: sessionId, 
          p_threadId: threadId,
          p_status: "success"
        },
        req.telemetryContext 
      )

        res.json({ result, runId });

    } catch (error) {
        console.error("Backend API error:", error);
        emitEvent(
          "ChatEvent",
          {
            p_question: message,
            p_age: age,
            p_language: language,
            p_sessionId: sessionId, 
            p_threadId: threadId,
            p_status: "failure"
          },
          req.telemetryContext
        )
        res.status(500).json({ error: error.message });
    }
});


// Session-thread mapping with concurrency control
const sessionThreadMap = new Map();
const mapMutex = new Mutex();
const sessionRunMap = new Map();

export const runAssistantBackend = async (
  message,
  threadId,
  age,
  language = 'en',
  sessionId
) => {
  try {
    console.log("Received message: " + message);
    console.log("Received age: " + age);
    console.log("Received language: " + language);
    console.log("Received sessionId: " + sessionId);
    console.log("Received threadId: " + threadId);

    const assistantsClient = getAssistantClient();
    const assistant = getAssistant();

    // Get or create a dedicated chat thread per session
    const chatThreadId = await getOrCreateThread(sessionId);
    console.log("Using chat thread id: " + chatThreadId);

    // Add user's message
    await assistantsClient.beta.threads.messages.create(chatThreadId, {
      role: "user",
      content: message,
    });

    // Run assistant
    const run = await assistantsClient.beta.threads.runs.create(chatThreadId, {
      assistant_id: assistant.id,
      instructions: `Respond to ${message} as if you are an assistant that tailors responses based on the user's age: ${age} and language: ${language}. You cater to three different age groups: 5 through 8, 9 through 12, and 13 through 16. If no age group is specified, assume the user is in the 9 though 12 age group. If the age group is specified, respond to the question with an answer that is relevant to ${age} age group only. The answer must be precise, concise, and age-appropriate, and should not exceed 5 sentences in ${language} language only.

      Instructions for Every Response:
       Do not use response generated by the chatbot in ${message} as a question. Use the previous conversation in the thread to maintain continuity. Do not generate random answers to incomplete questions.
       Always reference the entire previous conversation in this thread to maintain continuity and context.

      If a user question is incomplete or ambiguous, do not generate a random answer. Instead, infer the most likely intent based on the most recent relevant messages in the thread. If context is insufficient, politely ask for clarification while referencing the last discussed topic.

      Never treat any message in isolation; always respond as part of a continuous, multi-turn conversation.

      Include a Mermaid diagram that illustrates the concept only if it is relevant for ${age} age and the first response only**
      All explanantion should be in ${language} ONLY. Use scientific vocabulary**.
      

      Place all Mermaid code inside a markdown code block labeled with mermaid.

      Node labels: Use exactly one pair of straight double quotes, in ${language}, with emojis for engagement.

      Edge labels: Write in ${language}, do not use quotes.

      Assign each node a unique class for pastel backgrounds using classDef and class.

      Do not use unsupported syntax like ::end or unrecognized keywords.

      The code must be valid, error-free, and renderable in any Mermaid-compatible viewer.
      All nodes, edges, and class definitions must be syntactically correct and closed.
      Each node name is separated by a comma without spaces.
      Test your code mentally for errors before submitting.
      
      If you are not certain about advanced Mermaid features, generate a simple diagram that is guaranteed to be valid.
      Keep the diagram simple, focusing on clarity and educational value for ${age} age group.

      Keep diagrams simple for younger audiences; add complexity for older learners.

      Do not use dark colors backgrounds to ensure readability and visual appeal.

      Do not include any ASCII art.

      After the diagram, briefly explain the concept in one or two sentences, using age-appropriate and fun language for the specified age group ${age} in ${language}.


      For ages 13 through 16, always use mathematical or chemical equations in LaTeX (inside $$ ... $$) when relevant.

      In the end, offer atleast 3 age-appropriate follow-up STEM questions related to the concept for ${age}, which you can answer as a tutor to further their understanding of the topic.Do not ask anything outside of the topic.Each question must be inside a markdown code block, labeled with "followUpQuestions".
      Only ask factual, STEM-related questions that deepen understanding of the current topic. 
      Do not ask about feelings, preferences, favorites,colors, or any personal matters.
      Do not use like or dislike types of questions. The questions must be strictly related to the STEM concept ${message} and answerable by a tutor, and not open-ended that require personal opinions.
      Do not use imagination or hypothetical scenarios.
      Each question must be strictly related to the STEM concept above and answerable by a tutor.
      Each question must be inside a markdown code block labeled "followUpQuestions". 
      Do not repeat the original or previous questions.
      Do not use any introduction or explanation. Each question must be inside a markdown code block, labeled with "followUpQuestions".
      If the answer to the follow up STEM questions is not related to STEM, rephrase it to make it STEM-related.
      Do not repeat the original or follow up questions in subsequent questions.
      Always ask follow up questions that you can answer and they should always be STEM related.
      Dont use phrases like 'Here are some follow-up questions related to'.
      

      Additionally, do not specify that the diagram is a Mermaid diagram; just call it a diagram.

      When including LaTeX or Markdown in the JSON, always double-escape each backslash (e.g., use \\\\rightarrow in JSON for \\rightarrow in LaTeX). Do NOT use a single backslash unless it is part of a valid JSON escape.
      All LaTeX and Markdown in the JSON must be valid JSON strings.

      If the topic is not directly related to Science (phsyics, chemistry, biology, computer science, etc.), Technology, Engineering, or Math, kindly state that the topic is irrelevant to STEM and prompt the user to bring the conversation back to something STEM-related.`,
      model: assistant.model
    });

    // Store run info for potential cancellation
    sessionRunMap.set(sessionId, { threadId: chatThreadId, runId: run.id });

    // Poll for completion
    let runStatus = run.status;
    while (runStatus === 'queued' || runStatus === 'in_progress') {
      await new Promise(resolve => setTimeout(resolve, 1000));
      const runStatusResponse = await assistantsClient.beta.threads.runs.retrieve(
        chatThreadId,
        run.id
      );
      runStatus = runStatusResponse.status;
    }

    // Return both result and runId
    if (runStatus === 'completed') {
      const messages = await assistantsClient.beta.threads.messages.list(chatThreadId);
      const latestAssistantMsg = messages.data.find(m => m.role === 'assistant');
      const result = latestAssistantMsg?.content?.[0]?.text?.value ?? "(No response)";
      
      
      return { 
        result, 
        runId: run.id 
      };
    } else {
      throw new Error(`Run failed with status: ${runStatus}`);
    }
  } catch (error) {
    console.error(`Error running assistant: ${error.message}`);
    throw error;
  }
};

export default router;