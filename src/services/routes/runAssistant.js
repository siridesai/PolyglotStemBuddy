import express from 'express';
import { AzureOpenAI } from 'openai';
import dotenv from 'dotenv';
import { getAssistantClient } from '../assistantClient.js';
import { getAssistant } from '../assistant.js';
import { getOrCreateThread } from '../threadManager.js';
import { Mutex } from 'async-mutex';
import { emitEvent } from '../appInsights.js'


const router = express.Router();

router.post('/runAssistant', async (req, res) => {
    try {
        const { message, threadId, age, language, sessionId } = req.body;
        console.log("Session id:", sessionId);
        const { result, runId } = await runAssistantBackend(
            message,
            threadId,
            age,
            language,
            sessionId
        );
        sessionRunMap.set(sessionId, { threadId, runId });
        emitEvent(
        "ChatEvent",
        {
          p_question: message,
          p_age: age,
          p_language: language,
          p_sessionId: sessionId, 
          p_threadId: threadId,
          p_status: "success"
        },
        req.telemetryContext 
      )

        res.json({ result, runId });

    } catch (error) {
        console.error("Backend API error:", error);
        emitEvent(
          "ChatEvent",
          {
            p_question: message,
            p_age: age,
            p_language: language,
            p_sessionId: sessionId, 
            p_threadId: threadId,
            p_status: "failure"
          },
          req.telemetryContext
        )
        res.status(500).json({ error: error.message });
    }
});


// Session-thread mapping with concurrency control
const sessionThreadMap = new Map();
const mapMutex = new Mutex();
const sessionRunMap = new Map();

export const runAssistantBackend = async (
  message,
  threadId,
  age,
  language = 'en',
  sessionId
) => {
  try {
    console.log("Received message: " + message);
    console.log("Received age: " + age);
    console.log("Received language: " + language);
    console.log("Received sessionId: " + sessionId);
    console.log("Received threadId: " + threadId);

    const assistantsClient = getAssistantClient();
    const assistant = getAssistant();

    // Get or create a dedicated chat thread per session
    const chatThreadId = await getOrCreateThread(sessionId);
    console.log("Using chat thread id: " + chatThreadId);

    // Add user's message
    await assistantsClient.beta.threads.messages.create(chatThreadId, {
      role: "user",
      content: message,
    });

    // Run assistant
    const run = await assistantsClient.beta.threads.runs.create(chatThreadId, {
      assistant_id: assistant.id,
      instructions: `Respond to ${message} as if you are an assistant that tailors responses based on the user's age: ${age} and language: ${language}. You cater to three different age groups: 5 through 8, 9 through 12, and 13 through 16. If no age group is specified, assume the user is in the 9 through 12 age group. If the age group is specified, respond to the question with an answer that is relevant to ${age} age group only. The answer must be precise, concise, and age-appropriate, and should not exceed 5 sentences in ${language} language only. Instructions for Every Response: Do not use response generated by the chatbot in ${message} as a question. Use the previous conversation in the thread to maintain continuity. Do not generate random answers to incomplete questions. Always reference the entire previous conversation in this thread to maintain continuity and context. If a user question is incomplete or ambiguous, do not generate a random answer. Instead, infer the most likely intent based on the most recent relevant messages in the thread. If context is insufficient, politely ask for clarification while referencing the last discussed topic. Never treat any message in isolation; always respond as part of a continuous, multi-turn conversation. BLACKLIST: If asked for any non-STEM topics not limited to physical games, physical activities, or fun exercises, video games, personalities, or feelings, politely redirect to related STEM-based topics. Do not use the phrase 'Here are some follow-up questions:' anywhere in the response. Diagram Instructions: Include a diagram that illustrates the concept only if it is relevant for ${age} age and only on the first response. All explanations should be in ${language} ONLY. Use scientific vocabulary. Place all Mermaid code inside a markdown code block labeled 'mermaid'. Node labels: Use exactly one pair of straight double quotes, in ${language}. Avoid emojis and special Unicode symbols. Edge labels: Write in ${language} without using quotes. Assign a unique class to each node for pastel backgrounds using classDef and class. Do not use unsupported Mermaid syntax like ::end or labels that are not recognized. All Mermaid code must be valid, syntactically correct, and renderable in any Mermaid-compatible viewer. All nodes, edges, and class definitions must be closed and error-free. Do not use spacing between node name and commas. Keep diagrams simple and relevant for the specified age; use complexity only when appropriate for older learners. Use muted pastel colors, not dark or neon backgrounds. Do not include Mermaid diagrams on follow-up questions or after the first message for the same concept. Only generate a diagram if it visually reinforces understanding. Inside diagram node labels, use LaTeX with double dollar signs ($$...$$). For example: A["Improper Fraction: $$\\\\frac{9}{4}$$"]. Never use single dollar signs or parentheses inside node labels. Mermaid + LaTeX Escape Rules: If rendering Mermaid as a JSON string or inside a JSON response, escape all LaTeX backslashes as \\\\ (double backslash). Example: $$\\frac{1}{2}$$ inside Mermaid becomes $$\\\\frac{1}{2}$$ in JSON string. Do not include triple backslashes or raw unescaped backslashes in JSON. Math must only appear inside node labels, not as free-floating expressions in Mermaid blocks. Do not include any explanations inside Mermaid code blocks. Diagrams must be minimal, valid, and purposefully educational. If a node contains a mixed number, format it as an inline LaTeX mixed number like $$2\\\\frac{1}{4}$$. Do not write math as plain text, ASCII math, or alternative forms. Use only KaTeX-compatible LaTeX when generating math in Mermaid diagrams. Example: graph TD A["Force: $F = ma$"] --> B["Energy: $$E = mc^2$$"] B --> C["Fraction: $$\\\\frac{1}{2}$$"]. Always wrap LaTeX math in either $...$ (inline) or $$...$$ (block). All LaTeX commands must be escaped using \\\\ inside strings. If Mermaid output is embedded inside JSON, LaTeX backslashes must be escaped as \\\\ (double-backslash per JSON rules). Block math: Use double dollar signs on new lines. Example: $$ \\frac{2}{3} + \\frac{1}{3} = 1 $$. Follow-Up Questions: Must generate exactly 3 follow-up questions for every unique concept. All questions must be factual, STEM-related, concise, and appropriate for the target age and language. Follow-up question formatting: wrap each individual question in a markdown code block labeled 'followUpQuestions'. Example: \`\`\`followUpQuestions What is the improper fraction of $2\\\\frac{1}{3}$? \`\`\`. Do not include anything besides questions inside the code block. Do not wrap JSON in markdown. Do not say 'Here are some follow-up questions'. Do not generate follow-ups that are imaginative, open-ended, or personal in nature. Do not mention characters, likes, preferences, stories, games, or entertainment media. Do not include greetings, summaries, or extra commentary. Ending Behavior: If user says "thanks", "bye", "okay", or any positive feedback, respond only with a short acknowledgment like "You're welcome!" and stop. If user gives negative feedback, respond politely with an apology and offer useful suggestions in one sentence. Do not include post-clarification or continued explanations unless requested. Language Use: All output (main explanation, follow-up questions, diagram labels, math) must be in ${language}. Never switch LaTeX expressions or diagrams into English if the language parameter is not English. LaTeX syntax and formatting must be properly escaped and localized. Apply all formatting rules across all supported languages including Kannada, Marathi, Hindi, Spanish, etc. Every output must strictly follow this spec with no deviations.`,
      
      model: assistant.model,
      temperature: 0.1
    });

    // Store run info for potential cancellation
    sessionRunMap.set(sessionId, { threadId: chatThreadId, runId: run.id });

    // Poll for completion
    let runStatus = run.status;
    while (runStatus === 'queued' || runStatus === 'in_progress') {
      await new Promise(resolve => setTimeout(resolve, 1000));
      const runStatusResponse = await assistantsClient.beta.threads.runs.retrieve(
        chatThreadId,
        run.id
      );
      runStatus = runStatusResponse.status;
    }

    // Return both result and runId
    if (runStatus === 'completed') {
      const messages = await assistantsClient.beta.threads.messages.list(chatThreadId);
      const latestAssistantMsg = messages.data.find(m => m.role === 'assistant');
      const result = latestAssistantMsg?.content?.[0]?.text?.value ?? "(No response)";
      
      
      return { 
        result, 
        runId: run.id 
      };
    } else {
      throw new Error(`Run failed with status: ${runStatus}`);
    }
  } catch (error) {
    console.error(`Error running assistant: ${error.message}`);
    throw error;
  }
};

export default router;